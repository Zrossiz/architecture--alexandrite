Мотивация
В данный момент MES испытывает слишком большую нагрузку на чтение от операторов. Для решение проблемы нужно внедрить кеширование для уменьшения количества тяжелых запросов к БД

Предлагаемое решение
Кеширование на сервере при помощи паттерна cache aside. Для кеширования используем Redis.
Кешируем задачи по статусам + получение новых заказов (с маленьким ttl)
Cache-Aside позволяет загружать данные в кеш только при обращении к ним и обновлять по необходимости, что подходит для текущей задачи:
Операторы запрашивают данные — если в кеше нет, данные берутся из MES и сохраняются в кеш.
При изменении статуса заказа кеш инвалидируется по ключу или обновляется программно.
Почему не Write-Through:
Неоправдан для редко читаемых данных.
Избыточная нагрузка на кеш при каждой записи, которая здесь нечаста.
Почему не Refresh-Ahead:
Повышает сложность реализации.
Необходимость точного прогнозирования часто запрашиваемых данных — на текущем этапе нет достаточной статистики.

Диаграмма последовательностей
Получение списка заказов
Оператор
   |
   |--> UI (Dashboard)
           |
           |--> MES API
                   |
                   |--> Redis (GET "orders:dashboard")
                          |
                         MISS
                          |
                   |--> DB (SELECT * FROM orders WHERE status IN ('new', 'in_progress'))
                          |
                   |<-- [list of orders]
                   |
                   |--> Redis (SET "orders:dashboard", TTL 60s)
           |
   |<-- [orders from cache or DB]

2 Изменение статуса заказа
Оператор
   |
   |--> UI (change status)
           |
           |--> MES API
                   |
                   |--> DB (UPDATE orders SET status = ...)
                   |
                   |--> Redis (DEL "orders:dashboard")
           |
   |<-- OK

Стратегия обновлениея кеширования ttl + инвалидация кеша программным путем
При помощи инвалидации кеша программным путем данные всегда будут консистентными
Если произойдет какой-то сбой при инвалидации - ttl нас подстрахует
| Стратегия                | Преимущества                                                        | Недостатки                                                                     | Комментарий                                         |
| ------------------------ | ------------------------------------------------------------------- | ------------------------------------------------------------------------------ | --------------------------------------------------- |
| **Программная по ключу** | ✅ Мгновенная реакция на изменения данных<br>✅ Контроль кеша вручную | ❗ Требует дисциплины<br>❗ Можно забыть инвалидацию в каком-то участке          | **Выбранная как основная**                          |
| **Временная (TTL)**      | ✅ Простота реализации<br>✅ Защита от устаревших данных              | ❗ Задержка обновления до TTL (например, 60 секунд)                             | **Дополнение к программной, даёт страховку**        |
| **Refresh-Ahead**        | ✅ Предиктивная подгрузка<br>✅ Высокий шанс кеш-хита                 | ❗ Сложность в предсказании спроса<br>❗ Повышенная нагрузка                     | Неоправдано на текущем объёме и динамике            |
| **Write-Through**        | ✅ Согласованность кеша и базы<br>✅ Без пропуска обновлений          | ❗ Нагрузка на кеш при каждом обновлении<br>❗ Не подходит при низкой читаемости | Неэффективен для дашборда, данные обновляются редко |
